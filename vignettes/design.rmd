Design considerations for the CDA package
========================================================


## Description of a cluster at the R level

A cluster describes the geometry of N particles in a list,

* positions is a data.frame of 3 columns (x, y, z) and N rows

* angles is a data.frame of 3 columns (x, y, z) and N rows 

* sizes is a data.frame of 3 columns (x, y, z) and N rows

## Polarisability

The principal values of the inverse polarisability tensor of every particle are passed in a matrix Beta, with 3N rows (1/$\alpha_x$,1/$\alpha_y$,1/$\alpha_z$) for N particles, and Nlambda columns.

This matrix is formed from the sizes of the cluster, and the material and medium properties.

## Functions at the C++ level

### CDA

* `incident_field` Calculate the incident field at each dipole location 

* `block_diagonal` Construct the diagonal blocks of the interaction matrix

* `interaction_matrix` Construct the full interaction matrix

* `extinction` Calculate the extinction cross-section for multiple incident angles

* `absorption` Calculate the absorption cross-section for multiple incident angles


### CD

* `averaging` Performs full angular averaging for both circular polarisations

* `average_spectrum` Angular-average spectra for LCP and RCP polarisations 

### Dispersion

* `multiple_incident_field` Incident field along multiple axes

* `dispersion` Angle-resolved cross-sections for multiple directions of incidence

* `dispersion_spectrum` Angle-resolved spectra for linear or circular polarisations

### Linear



### Utils




## Minimal code in R

## Structure of the core components

Simulated spectra are obtained for a vector of wavelengths, with length Nlambda, and a cluster size N.

* Wavelength-dependent values

Beta is a matrix of size 3N x Nlambda (rows x columns). It is passed to xxx_spectrum functions at the cpp level, and is passed one row at a time to the functions operating one wavelength at a time.

      beta = reshape(Beta.row(ll), 3, Nr, 1); 

Not true, change this without reshaping beta every time

Integrate diagonal into main A function and don't build a useless matrix


------

Beta is 3N x Nlambda
Euler is 3xN matrix
R is a 3xN matrix
Angle is a 3xN matrix
Axis is a 3xN matrix

-----

beta is Beta.col(ii)
block diagonal becomes
trans(Euler.col(ii)) * diagmat(beta(jj:jj+3)) * Euler.col(ii)



* Diagonal blocks

* Interaction matrix

